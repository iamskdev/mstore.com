> **DOCUMENT AUDIT**
> - **Status:** `Updated`
> - **Last Reviewed:** 2025-10-05 18:30:00 IST
> - **Reviewer:** Santosh (with Gemini)
> - **Purpose:** This document serves as the main entry point for understanding the project's features, architecture, and setup instructions. It is intended for all developers joining the project.

---

# mStore - स्थानीय दुकानों के लिए PWA

स्थानीय दुकानों के लिए एक आधुनिक, मोबाइल-फर्स्ट प्रोग्रेसिव वेब ऐप (PWA), जिसे एक मॉड्यूलर, कंपोनेंट-आधारित आर्किटेक्चर के साथ डिज़ाइन किया गया है। इसमें एक डायनामिक, भूमिका-आधारित इंटरफ़ेस है जो विभिन्न प्रकार के उपयोगकर्ताओं के अनुकूल होता है, जो मेहमानों, ग्राहकों, व्यापारियों और प्रशासकों के लिए एक अनुकूलित अनुभव प्रदान करता है।

---

# `lang-key` Attribute Usage Guide

## क्या है `lang-key`?

`lang-key` एक कस्टम HTML attribute है जो बताता है कि उस element का text translation के लिए ज़रूरी है। इसमें जो value होती है, वही translation JSON फाइल में key के रूप में इस्तेमाल होती है।

---

## क्यों इस्तेमाल करें?

- HTML साफ़ रहता है, कोई hardcoded text नहीं होता।  
- Translation keys को आसानी से track और manage किया जा सकता है।  
- JavaScript के ज़रिए language के हिसाब से text dynamically बदल सकते हैं।  
- मल्टी-लैंग्वेज सपोर्ट आसान बनता है।

---

## ✨ मुख्य विशेषताएँ (Core Features)

-   **भूमिका-आधारित UI:** इंटरफ़ेस **मेहमानों (Guests)**, पंजीकृत **उपभोक्ताओं (Consumers)**, **व्यापारियों (Merchants)**, और **एडमिन (Admins)** के लिए गतिशील रूप से अनुकूल होता है।
-   **रेटिंग सिस्टम (Rating System):** एक उन्नत, गतिशील रेटिंग सिस्टम जो उपयोगकर्ताओं को 1-5 स्टार रेटिंग, विस्तृत टिप्पणी और अनुभव टैग (जैसे "Fast", "Great UI") के माध्यम से अपनी प्रतिक्रिया देने की अनुमति देता है। यह सुविधा सीधे ऐप के ड्रॉअर और अकाउंट पेज से उपलब्ध है।
-   **अकाउंट स्विचिंग (Account Switching):** उपयोगकर्ताओं को ऐप के भीतर कई भूमिकाओं (जैसे उपयोगकर्ता, व्यापारी, व्यवस्थापक) के बीच सहजता से स्विच करने की अनुमति देता है, प्रत्येक भूमिका के लिए एक अलग डैशबोर्ड और अनुभव प्रदान करता है।
-   **स्टोरी फ़ीचर (Story Feature):**
    -   **यह क्या है?** एक पूरी तरह से कार्यात्मक स्टोरी व्यूअर जो व्यापारियों को इंस्टाग्राम या व्हाट्सएप की तरह अस्थायी अपडेट (स्टेटस) पोस्ट करने की अनुमति देता है।
    -   **यह कैसे काम करता है?** व्यापारी चित्र, वीडियो और टेक्स्ट वाली स्टोरीज़ बना सकते हैं। उपयोगकर्ता इन स्टोरीज़ को अपडेट फ़ीड में देख सकते हैं। स्टोरीज़ 24 घंटे के बाद अपने आप समाप्त हो जाती हैं।
    -   **प्रमुख क्षमताएं:**
        -   **मल्टी-मीडिया सपोर्ट:** चित्र और भविष्य में वीडियो के लिए समर्थन।
        -   **ऑटो-प्ले:** स्टोरीज़ स्वचालित रूप से एक के बाद एक चलती हैं।
        -   **इंटरैक्टिव:** उपयोगकर्ता स्टोरीज़ का जवाब दे सकते हैं और उन्हें लाइक कर सकते हैं।
        -   **मालिक बनाम दर्शक मोड:** व्यापारी अपनी स्टोरीज़ के लिए व्यू काउंट और अन्य इनसाइट्स देख सकते हैं, जबकि दर्शक मैसेजिंग और लाइकिंग सुविधाओं का उपयोग कर सकते हैं।
        -   **कॉन्फ़िगर करने योग्य:** उपयोगकर्ता ऑटो-प्ले, स्वाइप नेविगेशन और स्टोरी की अवधि जैसी सेटिंग्स को समायोजित कर सकते हैं।
-   **अपडेट फ़ीड (Updates Feed):**
    -   **यह क्या है?** यह एक इंस्टाग्राम या फेसबुक जैसी व्यक्तिगत समाचार फ़ीड है जो अब डमी डेटा के बजाय फायरस्टोर से लाइव डेटा का उपयोग करती है।
    -   **यह कैसे काम करता है?** जब कोई उपयोगकर्ता किसी व्यापारी का अनुसरण करता है, तो उस व्यापारी की नई स्टोरीज़, उत्पाद, ऑफ़र और घोषणाएं स्वचालित रूप से उपयोगकर्ता की अपडेट फ़ीड में दिखाई देती हैं।
    -   **नई सुविधाएँ:**
        -   **व्यापारी के लिए 'माय स्टेटस':** व्यापारियों के लिए एक 'माय स्टेटस' सुविधा शामिल है, जिससे वे अपनी प्रोफ़ाइल देख सकते हैं।
        -   **उन्नत फ़िल्टरिंग:** फ़ीड को उत्पाद, सेवा, ऑफ़र और पोस्ट के अनुसार फ़िल्टर किया जा सकता है।
    -   **लाभ:** यह सुविधा उपयोगकर्ताओं को उनकी पसंदीदा दुकानों से जोड़े रखती है और व्यापारियों को अपने उत्पादों को सीधे अपने सबसे वफादार ग्राहकों के सामने प्रदर्शित करने का एक सीधा तरीका प्रदान करती है।
-   **कंपोनेंट-आधारित आर्किटेक्चर:** हेडर, फुटर, ड्रॉअर और टैब नेविगेशन जैसे मॉड्यूलर कंपोनेंट्स के लिए HTML पार्शियल का उपयोग करता है, जो गतिशील रूप से लोड होते हैं।
-   **डायनामिक हेडर (Dynamic Header):** हेडर अब व्यू के प्रकार के अनुसार बदलता है, जो `routes.js` में `isMainTab` ध्वज द्वारा नियंत्रित होता है।
-   **मुख्य टैब (Main Tabs):** `isMainTab: true` वाले व्यू (जैसे होम, अकाउंट) ऐप का नाम और कॉन्फ़िगर करने योग्य लोगो या मेनू आइकन दिखाते हैं।
-   **सेकेंडरी व्यू (Secondary Views):** अन्य सभी व्यू (जैसे सेटिंग्स, नोटिफिकेशन्स, या लॉगिन) एक **बैक बटन** और व्यू का शीर्षक दिखाते हैं, जिससे नेविगेशन सहज और अनुमानित होता है।
-   **SPA-जैसी नेविगेशन:** `main.js` पूर्ण पेज रीलोड के बिना विभिन्न व्यू के बीच स्विचिंग को संभालता है, जो एक सहज और तेज़ उपयोगकर्ता अनुभव प्रदान करता है।
-   **केंद्रीकृत कॉन्फ़िगरेशन (`config.json`):** एक ही स्थान से ऐप के व्यवहार को नियंत्रित करें, जिसमें ऐप विवरण, डेटा स्रोत, UI सेटिंग्स (जैसे हेडर स्टाइल के लिए `"logo"`, `"menu"`, या `"both"`) और फीचर फ़्लैग्स शामिल हैं।
-   **डायनामिक थीमिंग:** लाइट/डार्क मोड का समर्थन करता है जो सिस्टम वरीयता का सम्मान करता है और उपयोगकर्ता की पसंद को `localStorage` में सहेजता है।
-   **डेटा स्रोत स्विचिंग:** `config.json` में `source.data` सेटिंग का उपयोग करके `firebase` (लाइव), `emulator` (स्थानीय परीक्षण), और `localstore` (मॉक JSON) डेटा स्रोतों के बीच आसानी से स्विच करें।
-   **PWA रेडी:** इंस्टॉलेबिलिटी और ऑफ़लाइन क्षमताओं के लिए एक सर्विस वर्कर और मैनिफेस्ट फ़ाइल शामिल है।
-   **प्रोफ़ाइल अपडेट (Profile Update):** उपयोगकर्ता अब अपनी प्रोफ़ाइल जानकारी, जैसे नाम, बायो और अवतार, को सीधे ऐप से अपडेट कर सकते हैं। यह सुविधा Cloudinary के साथ एकीकृत है ताकि प्रोफ़ाइल चित्रों को सीधे अपलोड किया जा सके।
-   **Cloudinary एकीकरण (Cloudinary Integration):** छवियों को संभालने के लिए Firebase स्टोरेज के बजाय Cloudinary का उपयोग किया जाता है। एक समर्पित क्लाउड फ़ंक्शन (`generateCloudinarySignature`) क्लाइंट-साइड पर API रहस्य को उजागर किए बिना सुरक्षित, सीधी अपलोड सुनिश्चित करता है।
-   **ग्लोबल ID सिस्टम (Global ID System):** एक मजबूत, टाइमस्टैम्प-आधारित ID जनरेशन सिस्टम (`TYPE-YYYYMMDD-HHMMSS-SSS-RRRR`) यह सुनिश्चित करता है कि सभी दस्तावेज़ (उपयोगकर्ता, आइटम, ऑर्डर आदि) में एक अद्वितीय, कालानुक्रमिक रूप से छाँटने योग्य और मानव-पठनीय पहचानकर्ता हो। - `docs/id-generation.md`.
-   **प्रमोशन सिस्टम:** किसी विशिष्ट व्यापारी को एक अनुकूलित, ब्रांडेड अनुभव के साथ प्रचारित करने के लिए एक डेटा-चालित प्रणाली।
-   **अभियान (Campaigns):** एक `campaigns` कलेक्शन के माध्यम से कई उपयोगकर्ताओं को एक साथ सूचनाएं और संदेश भेजने के लिए एक स्केलेबल सिस्टम।
-   **सब्सक्रिप्शन मॉडल (Subscription Model):** व्यापारियों और उपयोगकर्ताओं के लिए प्रीमियम सुविधाएँ प्रदान करने के लिए एक स्केलेबल डेटा संरचना, जो भविष्य में भुगतान गेटवे एकीकरण के लिए तैयार है।
-   **मजबूत प्रमाणीकरण (Robust Authentication)::** सभी साइन-अप विधियों (ईमेल, गूगल, एप्पल) के लिए एक केंद्रीकृत, पुन: प्रयोज्य फ़ंक्शन का उपयोग करके विश्वसनीय उपयोगकर्ता निर्माण। इसमें डेटा असंगतताओं के लिए एक सेल्फ-हीलिंग मैकेनिज्म भी शामिल है।
-   **उन्नत डेवलपर टूल:** एक इन-ऐप डेवलपर स्विचर जो न केवल भूमिकाओं के बीच स्विच करने की अनुमति देता है, बल्कि किसी भी उपयोगकर्ता का **रूप धारण (impersonate)** करने की भी अनुमति देता है, जिससे UI परीक्षण और डीबगिंग बहुत आसान हो जाती है।
-   **उन्नत सुरक्षा (Enhanced Security):** अनधिकृत डेटा एक्सेस को रोकने और यह सुनिश्चित करने के लिए कि उपयोगकर्ता केवल अपने डेटा को संशोधित कर सकते हैं, सख्त फायरस्टोर सुरक्षा नियम लागू किए गए हैं।
-   **डुप्लिकेट रोकथाम (Duplicate Prevention):** पंजीकरण के दौरान सिस्टम फायरबेस की अंतर्निहित क्षमता का उपयोग करके मौजूदा ईमेल की जाँच करता है। फ़ोन नंबर की जाँच को परीक्षण के लिए सक्षम या उत्पादन के लिए अक्षम किया जा सकता है।
-   **सुव्यवस्थित डेटा प्रबंधन:** `export-data.js` और `import-data.js` जैसे Node.js स्क्रिप्ट्स का उपयोग करके स्थानीय JSON फ़ाइलों और फायरस्टोर के बीच डेटा को आसानी से माइग्रेट करें।
-   **व्यू-आधारित डेटा निर्भरताएँ:** प्रत्येक व्यू अब अपनी आवश्यक डेटा निर्भरताओं को `view-config.js` में परिभाषित कर सकता है, जिससे `main.js` केवल आवश्यक डेटा को कुशलता से प्री-फ़ेच कर सके।

---

## 🔑 मुख्य आर्किटेक्चरल परिवर्तन (Key Architectural Changes)

-   **भूमिका का नाम बदलना (`user` -> `consumer`):** स्पष्टता और बेहतर डोमेन प्रतिनिधित्व के लिए `user` भूमिका को पूरे एप्लिकेशन में `consumer` के रूप में मानकीकृत किया गया है। यह परिवर्तन फायरस्टोर डेटा, सुरक्षा नियमों और सभी संबंधित फ्रंटएंड लॉजिक को प्रभावित करता है।
-   **एकीकृत स्कीमा (`feedbacks` और `ratings`):** `feedbacks` स्कीमा को अपडेट किया गया है और एक नया `ratings` स्कीमा पेश किया गया है। दोनों अब एक सुसंगत संरचना का पालन करते हैं, जिसमें एक मानकीकृत `submitter` ऑब्जेक्ट और एक `links` ऑब्जेक्ट शामिल है जो संबंधित दस्तावेजों (जैसे `userId`, `merchantId`) को स्पष्ट रूप से जोड़ता है।
-   **केंद्रीकृत प्रमाणीकरण तर्क:** उपयोगकर्ता और खाता दस्तावेज़ बनाने का तर्क अब `AuthService` में केंद्रीकृत है, जो `user-collection.js` और `account-collection.js` जैसी पुरानी फ़ाइलों को हटा देता है। यह एक अधिक सुव्यवस्थित और मजबूत साइन-अप प्रक्रिया सुनिश्चित करता है।

---

## 📁 फ़ोल्डर संरचना (Folder Structure)

प्रोजेक्ट को एक स्पष्ट और मॉड्यूलर संरचना के साथ व्यवस्थित किया गया है जो रखरखाव को आसान बनाता है:

```
mstore/
├── docs/                # विस्तृत दस्तावेज़ीकरण (जैसे workflow.md)
├── localstore/
│   ├── jsons/           # स्थानीय विकास के लिए मॉक JSON डेटा
│   └── ...              # बैकअप और अन्य स्थानीय डेटा
├── source/
│   ├── assets/          # लोगो, आइकन जैसे स्थिर एसेट
│   ├── common/          # सभी भूमिकाओं द्वारा साझा की गई स्क्रिप्ट और स्टाइल
│   ├── components/      # पुन: प्रयोज्य HTML, CSS, JS कंपोनेंट्स
│   │   ├── bottom/      # बॉटम नेविगेशन कंपोनेंट्स
│   │   ├── cards/       # कार्ड कंपोनेंट्स
│   │   ├── drawer/      # ड्रॉअर कंपोनेंट्स
│   │   ├── feedback-modal/ # फीडबैक मोडल कंपोनेंट्स
│   │   ├── footer/      # फुटर कंपोनेंट्स
│   │   ├── top/         # टॉप नेविगेशन कंपोनेंट्स
│   │   └── ...          # अन्य कंपोनेंट्स
│   ├── firebase/        # फायरबेस कॉन्फ़िगरेशन, नियम और व्यवस्थापक कुंजियाँ
│   ├── modules/         # भूमिका-विशिष्ट मॉड्यूल (जैसे उपभोक्ता, व्यापारी)
│   └── utils/           # ऐप-व्यापी उपयोगिताएँ (जैसे data-manager)
├── tools/
│   └── scripts/         # व्यवस्थापक और डेटा प्रबंधन के लिए Node.js स्क्रिप्ट्स
├── index.html           # मुख्य ऐप एंट्री पॉइंट
├── manifest.json        # PWA मैनिफेस्ट
└── service-worker.js    # PWA सर्विस वर्कर
```

---

## 📦 डेटा मॉडल (Data Models)

`localstore/jsons/` में प्रत्येक JSON फ़ाइल एक Firestore कलेक्शन का प्रतिनिधित्व करती है। यहाँ मुख्य मॉडलों का अवलोकन है:

-   **`users.json`**: ऐप के सभी उपयोगकर्ताओं (उपभोक्ता, व्यापारी, एडमिन) के लिए प्रोफ़ाइल जानकारी, भूमिकाएँ (जैसे `isSuperAdmin`), और प्रमाणीकरण विवरण संग्रहीत करता है। `consumer` भूमिका को दर्शाने के लिए अपडेट किया गया।
-   **`merchants.json`**: व्यापारियों के लिए स्टोरफ़्रंट जानकारी, जैसे दुकान का नाम, पता, लोगो, खुलने का समय और **सब्सक्रिप्शन स्थिति**।
-   **`items.json`**: व्यापारियों द्वारा बेचे जाने वाले उत्पादों और सेवाओं का विवरण, जिसमें मूल्य निर्धारण, स्टॉक और चित्र शामिल हैं।
-   **`stories.json`**: व्यापारियों द्वारा बनाई गई स्टोरीज़ को संग्रहीत करता है। प्रत्येक दस्तावेज़ एक व्यापारी से मेल खाता है और इसमें उनकी सभी सक्रिय स्टोरीज़ का संग्रह होता है।
-   **`ratings.json`**: **(नया)** उपयोगकर्ताओं द्वारा प्रस्तुत की गई रेटिंग्स को संग्रहीत करता है, जिसमें स्टार मान, टिप्पणियाँ और टैग शामिल हैं।
-   **`feedbacks.json`**: उपयोगकर्ताओं से सामान्य प्रतिक्रिया संग्रहीत करता है। स्कीमा को `ratings` के साथ संरेखित करने और एक मानकीकृत `submitter` ऑब्जेक्ट शामिल करने के लिए अपडेट किया गया है।
-   **`categories.json`**: उत्पादों और सेवाओं को व्यवस्थित करने के लिए एक पदानुक्रमित श्रेणी संरचना।
-   **`orders.json`**: ग्राहकों द्वारा दिए गए ऑर्डर, जिसमें आइटम, डिलीवरी विवरण और भुगतान स्थिति शामिल है।
-   **`accounts.json`**: उपयोगकर्ता-विशिष्ट डेटा जैसे सेटिंग्स, डिवाइस जानकारी (`fcmToken` सहित), और **उपयोगकर्ता-स्तरीय सब्सक्रिप्शन** को संग्रहीत करता है। यह `users` दस्तावेज़ से जुड़ा हुआ है। `cart` और `saved` ऑब्जेक्ट्स को हटा दिया गया है।
-   **`alerts.json`**: व्यक्तिगत उपयोगकर्ता सूचनाएं, जैसे ऑर्डर अपडेट या प्रचार संदेश।
-   **`campaigns.json`**: कई उपयोगकर्ताओं को एक साथ संदेश भेजने के लिए अभियानों को परिभाषित करता है (जैसे, दिवाली की बिक्री की घोषणा)।
-   **`logs.json`**: महत्वपूर्ण घटनाओं (जैसे उपयोगकर्ता पंजीकरण, ऑर्डर निर्माण) को ऑडिटिंग और डिबगिंग के लिए लॉग करता है।

---

## ✨ नया: स्टोरी फ़ीचर का आर्किटेक्चर

स्टोरी फ़ीचर को मॉड्यूलर और डेटा-चालित होने के लिए डिज़ाइन किया गया है।

1.  **डेटा स्रोत (`stories.json` और `stories-schema.json`):**
    -   `stories.json` में वास्तविक स्टोरी सामग्री होती है, जिसे व्यापारी द्वारा समूहीकृत किया जाता है।
    -   `stories-schema.json` एक व्यापक खाका प्रदान करता है जो दिखाता है कि स्टोरी डेटा को कैसे संरचित किया जा सकता है, जिसमें मल्टी-मीडिया परतें, इंटरैक्टिव पोल, CTA बटन और विस्तृत एनालिटिक्स शामिल हैं।

2.  **डेटा फ़ेचिंग (`data-manager.js`):**
    -   `fetchAllStories()` फ़ंक्शन को `stories` संग्रह से डेटा लाने के लिए जोड़ा गया है।
    -   यह गैर-सरणी JSON प्रतिक्रियाओं (जैसे `stories.json` जो एक वस्तु है) को संभालने के लिए एक सुधार शामिल करता है, यह सुनिश्चित करता है कि ऐप को हमेशा एक सरणी प्राप्त हो।

3.  **UI इंटीग्रेशन (`updates.js`):**
    -   `updates.js` में `init()` फ़ंक्शन अब `fetchAllStories()` को कॉल करता है।
    -   यह स्टोरी डेटा का उपयोग यह निर्धारित करने के लिए करता है कि किस व्यापारी के पास एक सक्रिय स्टोरी है और उनके अवतार के चारों ओर एक "has-story" रिंग प्रदर्शित करता है।
    -   जब कोई उपयोगकर्ता स्टोरी वाले अवतार पर क्लिक करता है, तो यह `storyViewer.open(merchantId)` को कॉल करता है।

4.  **स्टोरी व्यूअर (`story-viewer.js` और `story-viewer.html`):**
    -   **डायनामिक लोडिंग:** व्यूअर का HTML और JS केवल तभी लोड होता है जब कोई उपयोगकर्ता पहली बार किसी स्टोरी को खोलने का प्रयास करता है, जिससे प्रारंभिक ऐप लोड समय बचता है।
    -   **स्टेट मैनेजमेंट:** `story-viewer.js` सभी अवस्थाओं का प्रबंधन करता है, जिसमें `currentStoryIndex`, `isPaused`, और `isOwner` मोड शामिल है।
    -   **रेंडरिंग:** `showStory()` फ़ंक्शन `stories.json` से परत-आधारित डेटा के आधार पर सामग्री (छवि, टेक्स्ट ओवरले) को प्रस्तुत करता है। यह प्रगति बार भी बनाता है।
    -   **इंटरैक्शन:** यह स्वाइप नेविगेशन, टैप-टू-पॉज़, मैसेजिंग, लाइकिंग और मालिक-विशिष्ट इनसाइट्स को संभालता है।
    -   **सुरक्षा:** फायरस्टोर नियम (`firestore.rules`) यह सुनिश्चित करते हैं कि केवल स्टोरी का मालिक ही इसे बना, अपडेट या हटा सकता है, जबकि कोई भी इसे पढ़ सकता है।

---

## 🚀 टेक्नोलॉजी स्टैक

- **HTML5**
- **CSS3** (थीमिंग के लिए CSS वेरिएबल्स के साथ)
- **JavaScript (ES6+ मॉड्यूल्स)** - कोई फ्रेमवर्क नहीं, केवल शुद्ध वैनीला जेएस।
- **फायरबेस (Firebase):**
  - **फायरस्टोर (Firestore):** उपयोगकर्ताओं, व्यापारियों और आइटम के लिए प्राथमिक डेटाबेस के रूप में।
  - **प्रमाणीकरण (Authentication):** उपयोगकर्ता लॉगिन और पंजीकरण के लिए।
  - **एम्युलेटर सुइट (Emulator Suite):** ऑफ़लाइन विकास और परीक्षण के लिए।

---

## ⚙️ कोर आर्किटेक्चर और वर्कफ़्लो

एप्लिकेशन एक स्पष्ट, मॉड्यूलर और इवेंट-चालित आर्किटेक्चर का पालन करता है जो रखरखाव और विस्तार में आसानी सुनिश्चित करता है।

1.  **प्रारंभ (`index.html` और `main.js`):**
    -   ऐप `index.html` से शुरू होता है, जिसमें UI के लिए प्लेसहोल्डर होते हैं और यह सीधे `main.js` को एक मॉड्यूल के रूप में लोड करता है।
    -   `main.js` ऐप का मुख्य ऑर्केस्ट्रेटर है। यह सही क्रम में सब कुछ लोड करता:
        -   यह `config.json` से कॉन्फ़िगरेशन लोड करता है।
        -   यह फायरबेस सेवाओं को प्रारंभ करता है।
        -   यह सर्विस वर्कर को पंजीकृत करता है।

2.  **कंपोनेंट लोडिंग:**
    -   `main.js` में `initializeApp()` फ़ंक्शन अब `loadTopNavigation()`, `loadDrawer()`, और `loadBottomNavigation()` जैसे विशिष्ट फ़ंक्शंस का उपयोग करके UI कंपोनेंट्स को गतिशील रूप से लोड करता है। ये फ़ंक्शंस संबंधित HTML फ़ाइलों को फ़ेच करते हैं और उनके JavaScript लॉजिक को निष्पादित करते हैं, जिससे प्रत्येक कंपोनेंट का अपना एनकैप्सुलेटेड लॉजिक हो सकता है।

3.  **मुख्य ऐप लॉजिक (`main.js`):**
    -   एक बार जब सभी कोर कंपोनेंट्स सफलतापूर्वक लोड हो जाते हैं, तो `main.js` में `initializeApp()` फ़ंक्शन `routeManager.init()` को कॉल करके ऐप के नेविगेशन और स्टेट मैनेजमेंट को प्रारंभ करता है। `routeManager` अब `view-config.js` में परिभाषित `dataDependencies` के आधार पर प्रत्येक व्यू के लिए आवश्यक डेटा को प्री-फ़ेच करने का भी प्रबंधन करता है। `main.js` अब ऐप के नेविगेशन का "मस्तिष्क" है। यह URL हैश और उपयोगकर्ता की क्रियाओं के आधार पर प्रबंधित करता है कि कौन सा व्यू वर्तमान में दिखाई दे रहा है।

4.  **प्रमाणीकरण और डेटा प्रवाह (Authentication & Data Flow):**
    -   `auth.js` सभी प्रमाणीकरण प्रवाह (लॉगिन, साइनअप) को नियंत्रित करता है।
    -   लॉग इन या लॉग आउट होने पर, यह `AuthService.handleLogout()` को कॉल करता है, जो केंद्रीकृत रूप से `routeManager.handleRoleChange()` को संभालता है।
    -   व्यू मैनेजर `localStorage` में स्थिति को अपडेट करता है और फिर सभी सब्सक्राइब किए गए कंपोनेंट्स को सूचित करता है।

5.  **डायनामिक UI अपडेट:**
    -   `top-nav.js` अब `routes.js` से `isMainTab` ध्वज का उपयोग करके हेडर को गतिशील रूप से अपडेट करता है। मुख्य टैब पर, यह ऐप का नाम और लोगो/मेनू दिखाता है। सेकेंडरी व्यू पर, यह एक बैक बटन और व्यू का शीर्षक दिखाता है।
    -   `drawer/drawer.html` और `bottom/bottom-nav.html` जैसे कंपोनेंट्स व्यू मैनेजर से सूचना प्राप्त करते हैं।
    -   सूचना मिलने पर, वे अपने `update...UI()` फ़ंक्शंस को ट्रिगर करते हैं, `localStorage` से नवीनतम उपयोगकर्ता भूमिका पढ़ते हैं, और `data-manager.js` का उपयोग करके आवश्यक डेटा प्राप्त करते हैं। यह सुनिश्चित करता है कि UI हमेशा वर्तमान उपयोगकर्ता के संदर्भ को दर्शाता है और `view-config.js` में परिभाषित `dataDependencies` के आधार पर डेटा को प्री-फ़ेच किया जाता है।

6.  **डेटा सोर्स स्विचिंग (`config.json`, `data-manager.js`):**
    -   `config.json` में `source.data` कॉन्फ़िगरेशन से ऐप यह तय कर सकता है कि डेटा फायरबेस से लेना है या लोकल मॉक फ़ाइलों से।
    -   `data-manager.js` में डेटा फ़ेचिंग फ़ंक्शंस को अपडेट किया गया है ताकि वे `getAppConfig().source.data` की जाँच करें और उसके अनुसार या तो Firebase से या लोकल JSON फ़ाइलों से डेटा प्राप्त करें।

7.  **उन्नत पुल-टू-रिफ्रेश (Enhanced Pull-to-Refresh):**
    -   पुल-टू-रिफ्रेश कार्यक्षमता को `config.json` में `flags.ptrEnabled` के माध्यम से नियंत्रित किया जाता है।
    -   जब यह सक्षम होता है, तो `main.js` में `initializePullToRefresh()` इसे प्रबंधित करता है।
    -   जब उपयोगकर्ता पुल-टू-रिफ्रेश करता है, तो यह `routeManager.refreshCurrentView()` को कॉल करता है, जो वर्तमान में सक्रिय व्यू के लिए सामग्री को फिर से लोड करता है, जिससे एक सहज और अद्यतन उपयोगकर्ता अनुभव सुनिश्चित होता है।

---

## 👤 उपयोगकर्ता भूमिकाएँ

-   **मेहमान (Guest):** एक अप्रमाणित उपयोगकर्ता। उत्पादों और सेवाओं को ब्राउज़ कर सकता है।
-   **उपभोक्ता (Consumer):** एक लॉग-इन ग्राहक। आइटम सहेज सकता है, अपने खाते का प्रबंधन कर सकता है, और अन्य उपयोगकर्ता-विशिष्ट कार्य कर सकता है।
-   **व्यापारी (Merchant):** एक स्टोर का मालिक। इन्वेंट्री का प्रबंधन करने, एनालिटिक्स देखने और अपनी दुकान प्रोफ़ाइल को अपडेट करने के लिए एक समर्पित पैनल है।
-   **एडमिन (Admin):** एक डेवलपर या प्रशासक जिसके पास डेवलपर टूल, सिस्टम-व्यापी प्रबंधन सुविधाओं और सभी मोड में भूमिका-स्विचर तक पहुंच है।

---

## 🛠️ आरंभ करने के लिए

1.  **रिपॉजिटरी को क्लोन करें:**
    ```bash
    git clone <your-repo-url>
    ```
2.  **डिपेंडेंसीज इंस्टॉल करें:**
    यह कमांड `firebase-admin` पैकेज इंस्टॉल करेगा, जो व्यवस्थापक स्क्रिप्ट्स के लिए आवश्यक है।
    ```bash
    npm install
    ```
3.  **फायरबेस को कॉन्फ़िगर करें:**
    -   `/source/firebase/firebase-config.js` खोलें।
    -   प्लेसहोल्डर फायरबेस कॉन्फ़िगरेशन को अपने स्वयं के प्रोजेक्ट क्रेडेंशियल्स से बदलें।
    -   अपने फायरबेस प्रोजेक्ट से एक **सर्विस अकाउंट की (key)** डाउनलोड करें, उसका नाम बदलकर `serviceAccountKey.json` रखें, और उसे `/source/firebase/` डायरेक्टरी में रखें। **यह फ़ाइल संवेदनशील है, इसे Git पर कमिट न करें!**
4.  **फायरबेस CLI सेट करें:** यदि आपने पहले से नहीं किया है, तो फायरबेस कमांड-लाइन टूल्स इंस्टॉल करें: `npm install -g firebase-tools`।
5.  **स्थानीय रूप से चलाएँ:**
    -   फ़ाइलों को परोसने के लिए एक स्थानीय वेब सर्वर का उपयोग करें। VS कोड के लिए **Live Server** एक्सटेंशन एक बढ़िया विकल्प है।

---
## 🧪 परीक्षण के लिए उपयोगकर्ता कैसे बनाएँ
विस्तृत परीक्षण विधियों के लिए, कृपया `docs/workflow.md` फ़ाइल देखें। इसमें व्यवस्थापक-संचालित परीक्षण, UI-संचालित परीक्षण, और शक्तिशाली **उपयोगकर्ता प्रतिरूपण (User Impersonation)** सुविधा का उपयोग करने के निर्देश शामिल हैं।

---
## 📜 व्यवस्थापक स्क्रिप्ट्स का उपयोग कैसे करें
**महत्वपूर्ण:** इन स्क्रिप्ट्स को चलाने से पहले, सुनिश्चित करें कि `/source/firebase/serviceAccountKey.json` फ़ाइल मौजूद है।

-   **सभी स्थानीय JSON फ़ाइलों को लाइव फायरस्टोर पर अपलोड करने के लिए (सावधानी से उपयोग करें):**
    ```bash
    node tools/scripts/export-data.js
    ```

-   **केवल एक विशिष्ट JSON फ़ाइल (जैसे `users.json`) को अपलोड करने के लिए:**
    ```bash
    node tools/scripts/export-data.js users.json
    ```

-   **स्थानीय JSON डेटा को फायरबेस एम्युलेटर पर अपलोड करने के लिए (विकास के लिए अनुशंसित):**
    ```bash
    node tools/scripts/upload-to-emulator.js
    ```

-   **मॉक उपयोगकर्ताओं के लिए प्रमाणीकरण खाते बनाने के लिए:**
    ```bash
    node tools/scripts/create-auth-users.js
    ```

---

## 📢 प्रमोशन सिस्टम कैसे काम करता है

यह सिस्टम आपको किसी विशिष्ट व्यापारी को एक पूरी तरह से ब्रांडेड, अनुकूलित अनुभव के साथ प्रचारित करने की अनुमति देता है। यह ऐप के मुख्य UI घटकों को ओवरराइड करने के लिए एक डेटा-चालित दृष्टिकोण का उपयोग करता है।

### शामिल फाइलें:
-   **कॉन्फ़िगरेशन:** `/source/settings/config.json` (यहाँ आप `flags.promotionEnabled` को `true` पर सेट करते हैं)
-   **प्रमोशन डेटा:** `/localstore/jsons/promotions.json` (या Firestore में `promotions` कलेक्शन)
-   **मुख्य लॉजिक:** `/source/main.js`
-   **UI कंपोनेंट्स:** `/source/partials/navigations/top-nav.html`, `/source/partials/footer/footer.html`, `/source/partials/navigations/bottom-nav.html`

### वर्कफ़्लो:
1.  **सक्रियण:** `config.json` में, `flags.promotionEnabled` को `true` पर सेट करें।
2.  **प्रारंभ:** जब ऐप लोड होता है, तो `main.js` में `initializeApp` फ़ंक्शन जांचता है कि `flags.promotionEnabled` ध्वज `true` है या नहीं।
3.  **डेटा फ़ेच:** यह `data-manager.js` से `fetchActivePromotion()` को कॉल करता है, जो `promotions.json` से `isActive: true` वाले प्रमोशन को प्राप्त करता है।
4.  **इवेंट डिस्पैच:** यदि कोई सक्रिय प्रमोशन मिलता है, तो `main.js` एक वैश्विक `promotionActivated` कस्टम इवेंट भेजता है, जिसमें प्रमोशन का पूरा डेटा `event.detail` में होता है।
5.  **UI अपडेट:** `header.html`, `footer.html`, और `tab-nav.html` में स्क्रिप्ट्स इस `promotionActivated` इवेंट को सुनती हैं। जब इवेंट पकड़ा जाता है, तो वे अपने डिफ़ॉल्ट HTML और स्टाइल को प्रमोशन डेटा (जैसे कस्टम लोगो, रंग, लिंक और बटन) से ओवरराइड कर देते हैं, जिससे एक पूरी तरह से ब्रांडेड अनुभव बनता है।

## 🔮 भविष्य की योजनाएं (Future Plans)

-   **क्लाउड फंक्शन्स:** `campaigns` कलेक्शन के आधार पर स्वचालित रूप से अलर्ट बनाने जैसे बैकएंड लॉजिक को लागू करना।
-   **उन्नत कैशिंग:** मजबूत ऑफ़लाइन क्षमताओं के लिए IndexedDB का उपयोग करना।
-   **OTP-आधारित फ़ोन लॉगिन:** वर्तमान असुरक्षित फ़ोन नंबर लॉगिन को एक सुरक्षित, OTP-आधारित प्रणाली से बदलना।
-   **पूर्ण सब्सक्रिप्शन प्रबंधन:** भुगतान गेटवे (जैसे Stripe, Razorpay) को एकीकृत करना और सब्सक्रिप्शन योजनाओं के लिए स्वचालित नवीनीकरण और चालान-प्रक्रिया को संभालना।
-   **डेस्कटॉप व्यू:** `@media` क्वेरी के साथ डेस्कटॉप अनुभव में सुधार करना।
-   **एकीकृत परीक्षण (Unit & E2E Testing):** ऐप की स्थिरता और विश्वसनीयता सुनिश्चित करने के लिए Jest या Cypress जैसे फ्रेमवर्क को लागू करना。


---
