> **DOCUMENT AUDIT**
> - **Status:** `Updated`
> - **Last Reviewed:** 28/09/2025 17:00:00 IST (Updated by Gemini)
> - **Reviewer:** Santosh (with Gemini)
> - **Purpose:** This document serves as the main entry point for understanding the project's features, architecture, and setup instructions. It is intended for all developers joining the project.

---

# mStore - स्थानीय दुकानों के लिए PWA

स्थानीय दुकानों के लिए एक आधुनिक, मोबाइल-फर्स्ट प्रोग्रेसिव वेब ऐप (PWA), जिसे एक मॉड्यूलर, कंपोनेंट-आधारित आर्किटेक्चर के साथ डिज़ाइन किया गया है। इसमें एक डायनामिक, भूमिका-आधारित इंटरफ़ेस है जो विभिन्न प्रकार के उपयोगकर्ताओं के अनुकूल होता है, जो मेहमानों, ग्राहकों, व्यापारियों और प्रशासकों के लिए एक अनुकूलित अनुभव प्रदान करता है।

---

# `lang-key` Attribute Usage Guide

## क्या है `lang-key`?

`lang-key` एक कस्टम HTML attribute है जो बताता है कि उस element का text translation के लिए ज़रूरी है। इसमें जो value होती है, वही translation JSON फाइल में key के रूप में इस्तेमाल होती है।

---

## क्यों इस्तेमाल करें?

- HTML साफ़ रहता है, कोई hardcoded text नहीं होता।  
- Translation keys को आसानी से track और manage किया जा सकता है।  
- JavaScript के ज़रिए language के हिसाब से text dynamically बदल सकते हैं।  
- मल्टी-लैंग्वेज सपोर्ट आसान बनता है।

---

## ✨ मुख्य विशेषताएँ (Core Features)

-   **भूमिका-आधारित UI:** इंटरफ़ेस **मेहमानों (Guests)**, पंजीकृत **उपयोगकर्ताओं (Users)**, **व्यापारियों (Merchants)**, और **एडमिन (Admins)** के लिए गतिशील रूप से अनुकूल होता है।
-   **अकाउंट स्विचिंग (Account Switching):** उपयोगकर्ताओं को ऐप के भीतर कई भूमिकाओं (जैसे उपयोगकर्ता, व्यापारी, व्यवस्थापक) के बीच सहजता से स्विच करने की अनुमति देता है, प्रत्येक भूमिका के लिए एक अलग डैशबोर्ड और अनुभव प्रदान करता है।
-   **कंपोनेंट-आधारित आर्किटेक्चर:** हेडर, फुटर, ड्रॉअर और टैब नेविगेशन जैसे मॉड्यूलर कंपोनेंट्स के लिए HTML पार्शियल का उपयोग करता है, जो गतिशील रूप से लोड होते हैं।
-   **डायनामिक हेडर (Dynamic Header):** हेडर अब व्यू के प्रकार के अनुसार बदलता है, जो `routes.js` में `isMainTab` ध्वज द्वारा नियंत्रित होता है।
-   **मुख्य टैब (Main Tabs):** `isMainTab: true` वाले व्यू (जैसे होम, अकाउंट) ऐप का नाम और कॉन्फ़िगर करने योग्य लोगो या मेनू आइकन दिखाते हैं।
-   **सेकेंडरी व्यू (Secondary Views):** अन्य सभी व्यू (जैसे सेटिंग्स, नोटिफिकेशन्स, या लॉगिन) एक **बैक बटन** और व्यू का शीर्षक दिखाते हैं, जिससे नेविगेशन सहज और अनुमानित होता है।
-   **SPA-जैसी नेविगेशन:** `main.js` पूर्ण पेज रीलोड के बिना विभिन्न व्यू के बीच स्विचिंग को संभालता है, जो एक सहज और तेज़ उपयोगकर्ता अनुभव प्रदान करता है।
-   **केंद्रीकृत कॉन्फ़िगरेशन (`config.json`):** एक ही स्थान से ऐप के व्यवहार को नियंत्रित करें, जिसमें ऐप विवरण, डेटा स्रोत, UI सेटिंग्स (जैसे हेडर स्टाइल के लिए `"logo"`, `"menu"`, या `"both"`) और फीचर फ़्लैग्स शामिल हैं।
-   **डायनामिक थीमिंग:** लाइट/डार्क मोड का समर्थन करता है जो सिस्टम वरीयता का सम्मान करता है और उपयोगकर्ता की पसंद को `localStorage` में सहेजता है।
-   **डेटा स्रोत स्विचिंग:** `config.json` में `source.data` सेटिंग का उपयोग करके `firebase` (लाइव), `emulator` (स्थानीय परीक्षण), और `localstore` (मॉक JSON) डेटा स्रोतों के बीच आसानी से स्विच करें।
-   **PWA रेडी:** इंस्टॉलेबिलिटी और ऑफ़लाइन क्षमताओं के लिए एक सर्विस वर्कर और मैनिफेस्ट फ़ाइल शामिल है।
-   **प्रमोशन सिस्टम:** किसी विशिष्ट व्यापारी को एक अनुकूलित, ब्रांडेड अनुभव के साथ प्रचारित करने के लिए एक डेटा-चालित प्रणाली।
-   **अभियान (Campaigns):** एक `campaigns` कलेक्शन के माध्यम से कई उपयोगकर्ताओं को एक साथ सूचनाएं और संदेश भेजने के लिए एक स्केलेबल सिस्टम।
-   **सब्सक्रिप्शन मॉडल (Subscription Model):** व्यापारियों और उपयोगकर्ताओं के लिए प्रीमियम सुविधाएँ प्रदान करने के लिए एक स्केलेबल डेटा संरचना, जो भविष्य में भुगतान गेटवे एकीकरण के लिए तैयार है।
-   **मजबूत प्रमाणीकरण (Robust Authentication)::** सभी साइन-अप विधियों (ईमेल, गूगल, एप्पल) के लिए एक केंद्रीकृत, पुन: प्रयोज्य फ़ंक्शन का उपयोग करके विश्वसनीय उपयोगकर्ता निर्माण। इसमें डेटा असंगतताओं के लिए एक सेल्फ-हीलिंग मैकेनिज्म भी शामिल है।
-   **उन्नत डेवलपर टूल:** एक इन-ऐप डेवलपर स्विचर जो न केवल भूमिकाओं के बीच स्विच करने की अनुमति देता है, बल्कि किसी भी उपयोगकर्ता का **रूप धारण (impersonate)** करने की भी अनुमति देता है, जिससे UI परीक्षण और डीबगिंग बहुत आसान हो जाती है।
-   **उन्नत सुरक्षा (Enhanced Security):** अनधिकृत डेटा एक्सेस को रोकने और यह सुनिश्चित करने के लिए कि उपयोगकर्ता केवल अपने डेटा को संशोधित कर सकते हैं, सख्त फायरस्टोर सुरक्षा नियम लागू किए गए हैं।
-   **डुप्लिकेट रोकथाम (Duplicate Prevention):** पंजीकरण के दौरान सिस्टम फायरबेस की अंतर्निहित क्षमता का उपयोग करके मौजूदा ईमेल की जाँच करता है। फ़ोन नंबर की जाँच को परीक्षण के लिए सक्षम या उत्पादन के लिए अक्षम किया जा सकता है।
-   **सुव्यवस्थित डेटा प्रबंधन:** `export-data.js` और `import-data.js` जैसे Node.js स्क्रिप्ट्स का उपयोग करके स्थानीय JSON फ़ाइलों और फायरस्टोर के बीच डेटा को आसानी से माइग्रेट करें।
-   **व्यू-आधारित डेटा निर्भरताएँ:** प्रत्येक व्यू अब अपनी आवश्यक डेटा निर्भरताओं को `view-config.js` में परिभाषित कर सकता है, जिससे `main.js` केवल आवश्यक डेटा को कुशलता से प्री-फ़ेच कर सके।

---

## 📁 फ़ोल्डर संरचना (Folder Structure)

प्रोजेक्ट को एक स्पष्ट और मॉड्यूलर संरचना के साथ व्यवस्थित किया गया है जो रखरखाव को आसान बनाता है:

```
mstore/
├── docs/                # विस्तृत दस्तावेज़ीकरण (जैसे workflow.md)
├── localstore/
│   ├── jsons/           # स्थानीय विकास के लिए मॉक JSON डेटा
│   └── ...              # बैकअप और अन्य स्थानीय डेटा
├── source/
│   ├── assets/          # लोगो, आइकन जैसे स्थिर एसेट
│   ├── common/          # सभी भूमिकाओं द्वारा साझा की गई स्क्रिप्ट और स्टाइल
│   ├── components/      # पुन: प्रयोज्य HTML, CSS, JS कंपोनेंट्स
│   │   ├── bottom/      # बॉटम नेविगेशन कंपोनेंट्स
│   │   ├── cards/       # कार्ड कंपोनेंट्स
│   │   ├── drawer/      # ड्रॉअर कंपोनेंट्स
│   │   ├── feedback-modal/ # फीडबैक मोडल कंपोनेंट्स
│   │   ├── footer/      # फुटर कंपोनेंट्स
│   │   ├── top/         # टॉप नेविगेशन कंपोनेंट्स
│   │   └── ...          # अन्य कंपोनेंट्स
│   ├── firebase/        # फायरबेस कॉन्फ़िगरेशन, नियम और व्यवस्थापक कुंजियाँ
│   ├── modules/         # भूमिका-विशिष्ट मॉड्यूल (जैसे उपभोक्ता, व्यापारी)
│   └── utils/           # ऐप-व्यापी उपयोगिताएँ (जैसे data-manager)
├── tools/
│   └── scripts/         # व्यवस्थापक और डेटा प्रबंधन के लिए Node.js स्क्रिप्ट्स
├── index.html           # मुख्य ऐप एंट्री पॉइंट
├── manifest.json        # PWA मैनिफेस्ट
└── service-worker.js    # PWA सर्विस वर्कर
```

---

## 📦 डेटा मॉडल (Data Models)

`localstore/jsons/` में प्रत्येक JSON फ़ाइल एक Firestore कलेक्शन का प्रतिनिधित्व करती है। यहाँ मुख्य मॉडलों का अवलोकन है:

-   **`users.json`**: ऐप के सभी उपयोगकर्ताओं (ग्राहक, व्यापारी, एडमिन) के लिए प्रोफ़ाइल जानकारी, भूमिकाएँ (जैसे `isSuperAdmin`), और प्रमाणीकरण विवरण संग्रहीत करता है। `subscription` और `fcmToken` जैसे डिवाइस-विशिष्ट डेटा को `accounts.json` में स्थानांतरित कर दिया गया है।
-   **`merchants.json`**: व्यापारियों के लिए स्टोरफ़्रंट जानकारी, जैसे दुकान का नाम, पता, लोगो, खुलने का समय और **सब्सक्रिप्शन स्थिति**।
-   **`items.json`**: व्यापारियों द्वारा बेचे जाने वाले उत्पादों और सेवाओं का विवरण, जिसमें मूल्य निर्धारण, स्टॉक और चित्र शामिल हैं।
-   **`categories.json`**: उत्पादों और सेवाओं को व्यवस्थित करने के लिए एक पदानुक्रमित श्रेणी संरचना।
-   **`orders.json`**: ग्राहकों द्वारा दिए गए ऑर्डर, जिसमें आइटम, डिलीवरी विवरण और भुगतान स्थिति शामिल है।
-   **`accounts.json`**: उपयोगकर्ता-विशिष्ट डेटा जैसे सेटिंग्स, डिवाइस जानकारी (`fcmToken` सहित), और **उपयोगकर्ता-स्तरीय सब्सक्रिप्शन** को संग्रहीत करता है। यह `users` दस्तावेज़ से जुड़ा हुआ है। `cart` और `saved` ऑब्जेक्ट्स को हटा दिया गया है।
-   **`alerts.json`**: व्यक्तिगत उपयोगकर्ता सूचनाएं, जैसे ऑर्डर अपडेट या प्रचार संदेश।
-   **`campaigns.json`**: कई उपयोगकर्ताओं को एक साथ संदेश भेजने के लिए अभियानों को परिभाषित करता है (जैसे, दिवाली की बिक्री की घोषणा)।
-   **`logs.json`**: महत्वपूर्ण घटनाओं (जैसे उपयोगकर्ता पंजीकरण, ऑर्डर निर्माण) को ऑडिटिंग और डिबगिंग के लिए लॉग करता है।

---

## 🚀 टेक्नोलॉजी स्टैक

- **HTML5**
- **CSS3** (थीमिंग के लिए CSS वेरिएबल्स के साथ)
- **JavaScript (ES6+ मॉड्यूल्स)** - कोई फ्रेमवर्क नहीं, केवल शुद्ध वैनीला जेएस।
- **फायरबेस (Firebase):**
  - **फायरस्टोर (Firestore):** उपयोगकर्ताओं, व्यापारियों और आइटम के लिए प्राथमिक डेटाबेस के रूप में।
  - **प्रमाणीकरण (Authentication):** उपयोगकर्ता लॉगिन और पंजीकरण के लिए।
  - **एम्युलेटर सुइट (Emulator Suite):** ऑफ़लाइन विकास और परीक्षण के लिए।

---

## ⚙️ कोर आर्किटेक्चर और वर्कफ़्लो

एप्लिकेशन एक स्पष्ट, मॉड्यूलर और इवेंट-चालित आर्किटेक्चर का पालन करता है जो रखरखाव और विस्तार में आसानी सुनिश्चित करता है।

1.  **प्रारंभ (`index.html` और `main.js`):**
    -   ऐप `index.html` से शुरू होता है, जिसमें UI के लिए प्लेसहोल्डर होते हैं और यह सीधे `main.js` को एक मॉड्यूल के रूप में लोड करता है।
    -   `main.js` ऐप का मुख्य ऑर्केस्ट्रेटर है। यह सही क्रम में सब कुछ लोड करता:
        -   यह `config.json` से कॉन्फ़िगरेशन लोड करता है।
        -   यह फायरबेस सेवाओं को प्रारंभ करता है।
        -   यह सर्विस वर्कर को पंजीकृत करता है।

2.  **कंपोनेंट लोडिंग:**
    -   `main.js` में `initializeApp()` फ़ंक्शन अब `loadTopNavigation()`, `loadDrawer()`, और `loadBottomNavigation()` जैसे विशिष्ट फ़ंक्शंस का उपयोग करके UI कंपोनेंट्स को गतिशील रूप से लोड करता है। ये फ़ंक्शंस संबंधित HTML फ़ाइलों को फ़ेच करते हैं और उनके JavaScript लॉजिक को निष्पादित करते हैं, जिससे प्रत्येक कंपोनेंट का अपना एनकैप्सुलेटेड लॉजिक हो सकता है।

3.  **मुख्य ऐप लॉजिक (`main.js`):**
    -   एक बार जब सभी कोर कंपोनेंट्स सफलतापूर्वक लोड हो जाते हैं, तो `main.js` में `initializeApp()` फ़ंक्शन `routeManager.init()` को कॉल करके ऐप के नेविगेशन और स्टेट मैनेजमेंट को प्रारंभ करता है। `routeManager` अब `view-config.js` में परिभाषित `dataDependencies` के आधार पर प्रत्येक व्यू के लिए आवश्यक डेटा को प्री-फ़ेच करने का भी प्रबंधन करता है। `main.js` अब ऐप के नेविगेशन का "मस्तिष्क" है। यह URL हैश और उपयोगकर्ता की क्रियाओं के आधार पर प्रबंधित करता है कि कौन सा व्यू वर्तमान में दिखाई दे रहा है।

4.  **प्रमाणीकरण और डेटा प्रवाह (Authentication & Data Flow):**
    -   `auth.js` सभी प्रमाणीकरण प्रवाह (लॉगिन, साइनअप) को नियंत्रित करता है।
    -   लॉग इन या लॉग आउट होने पर, यह `AuthService.handleLogout()` को कॉल करता है, जो केंद्रीकृत रूप से `routeManager.handleRoleChange()` को संभालता है।
    -   व्यू मैनेजर `localStorage` में स्थिति को अपडेट करता है और फिर सभी सब्सक्राइब किए गए कंपोनेंट्स को सूचित करता है।

5.  **डायनामिक UI अपडेट:**
    -   `top-nav.js` अब `routes.js` से `isMainTab` ध्वज का उपयोग करके हेडर को गतिशील रूप से अपडेट करता है। मुख्य टैब पर, यह ऐप का नाम और लोगो/मेनू दिखाता है। सेकेंडरी व्यू पर, यह एक बैक बटन और व्यू का शीर्षक दिखाता है।
    -   `drawer/drawer.html` और `bottom/bottom-nav.html` जैसे कंपोनेंट्स व्यू मैनेजर से सूचना प्राप्त करते हैं।
    -   सूचना मिलने पर, वे अपने `update...UI()` फ़ंक्शंस को ट्रिगर करते हैं, `localStorage` से नवीनतम उपयोगकर्ता भूमिका पढ़ते हैं, और `data-manager.js` का उपयोग करके आवश्यक डेटा प्राप्त करते हैं। यह सुनिश्चित करता है कि UI हमेशा वर्तमान उपयोगकर्ता के संदर्भ को दर्शाता है और `view-config.js` में परिभाषित `dataDependencies` के आधार पर डेटा को प्री-फ़ेच किया जाता है।

6.  **डेटा सोर्स स्विचिंग (`config.json`, `data-manager.js`):**
    -   `config.json` में `source.data` कॉन्फ़िगरेशन से ऐप यह तय कर सकता है कि डेटा फायरबेस से लेना है या लोकल मॉक फ़ाइलों से।
    -   `data-manager.js` में डेटा फ़ेचिंग फ़ंक्शंस को अपडेट किया गया है ताकि वे `getAppConfig().source.data` की जाँच करें और उसके अनुसार या तो Firebase से या लोकल JSON फ़ाइलों से डेटा प्राप्त करें।

7.  **उन्नत पुल-टू-रिफ्रेश (Enhanced Pull-to-Refresh):**
    -   पुल-टू-रिफ्रेश कार्यक्षमता को `config.json` में `flags.ptrEnabled` के माध्यम से नियंत्रित किया जाता है।
    -   जब यह सक्षम होता है, तो `main.js` में `initializePullToRefresh()` इसे प्रबंधित करता है।
    -   जब उपयोगकर्ता पुल-टू-रिफ्रेश करता है, तो यह `routeManager.refreshCurrentView()` को कॉल करता है, जो वर्तमान में सक्रिय व्यू के लिए सामग्री को फिर से लोड करता है, जिससे एक सहज और अद्यतन उपयोगकर्ता अनुभव सुनिश्चित होता है।

---

## 👤 उपयोगकर्ता भूमिकाएँ

-   **मेहमान (Guest):** एक अप्रमाणित उपयोगकर्ता। उत्पादों और सेवाओं को ब्राउज़ कर सकता है।
-   **उपयोगकर्ता (User)::** एक लॉग-इन ग्राहक। आइटम सहेज सकता है, अपने खाते का प्रबंधन कर सकता है, और अन्य उपयोगकर्ता-विशिष्ट कार्य कर सकता है।
-   **व्यापारी (Merchant):** एक स्टोर का मालिक। इन्वेंट्री का प्रबंधन करने, एनालिटिक्स देखने और अपनी दुकान प्रोफ़ाइल को अपडेट करने के लिए एक समर्पित पैनल है।
-   **एडमिन (Admin):** एक डेवलपर या प्रशासक जिसके पास डेवलपर टूल, सिस्टम-व्यापी प्रबंधन सुविधाओं और सभी मोड में भूमिका-स्विचर तक पहुंच है।

---

## 🛠️ आरंभ करने के लिए

1.  **रिपॉजिटरी को क्लोन करें:**
    ```bash
    git clone <your-repo-url>
    ```
2.  **डिपेंडेंसीज इंस्टॉल करें:**
    यह कमांड `firebase-admin` पैकेज इंस्टॉल करेगा, जो व्यवस्थापक स्क्रिप्ट्स के लिए आवश्यक है।
    ```bash
    npm install
    ```
3.  **फायरबेस को कॉन्फ़िगर करें:**
    -   `/source/firebase/firebase-config.js` खोलें।
    -   प्लेसहोल्डर फायरबेस कॉन्फ़िगरेशन को अपने स्वयं के प्रोजेक्ट क्रेडेंशियल्स से बदलें।
    -   अपने फायरबेस प्रोजेक्ट से एक **सर्विस अकाउंट की (key)** डाउनलोड करें, उसका नाम बदलकर `serviceAccountKey.json` रखें, और उसे `/source/firebase/` डायरेक्टरी में रखें। **यह फ़ाइल संवेदनशील है, इसे Git पर कमिट न करें!**
4.  **फायरबेस CLI सेट करें:** यदि आपने पहले से नहीं किया है, तो फायरबेस कमांड-लाइन टूल्स इंस्टॉल करें: `npm install -g firebase-tools`।
5.  **स्थानीय रूप से चलाएँ:**
    -   फ़ाइलों को परोसने के लिए एक स्थानीय वेब सर्वर का उपयोग करें। VS कोड के लिए **Live Server** एक्सटेंशन एक बढ़िया विकल्प है।

---
## 🧪 परीक्षण के लिए उपयोगकर्ता कैसे बनाएँ
विस्तृत परीक्षण विधियों के लिए, कृपया `docs/workflow.md` फ़ाइल देखें। इसमें व्यवस्थापक-संचालित परीक्षण, UI-संचालित परीक्षण, और शक्तिशाली **उपयोगकर्ता प्रतिरूपण (User Impersonation)** सुविधा का उपयोग करने के निर्देश शामिल हैं।

---
## 📜 व्यवस्थापक स्क्रिप्ट्स का उपयोग कैसे करें
**महत्वपूर्ण:** इन स्क्रिप्ट्स को चलाने से पहले, सुनिश्चित करें कि `/source/firebase/serviceAccountKey.json` फ़ाइल मौजूद है।

-   **सभी स्थानीय JSON फ़ाइलों को लाइव फायरस्टोर पर अपलोड करने के लिए (सावधानी से उपयोग करें):**
    ```bash
    node tools/scripts/export-data.js
    ```

-   **केवल एक विशिष्ट JSON फ़ाइल (जैसे `users.json`) को अपलोड करने के लिए:**
    ```bash
    node tools/scripts/export-data.js users.json
    ```

-   **स्थानीय JSON डेटा को फायरबेस एम्युलेटर पर अपलोड करने के लिए (विकास के लिए अनुशंसित):**
    ```bash
    node tools/scripts/upload-to-emulator.js
    ```

-   **मॉक उपयोगकर्ताओं के लिए प्रमाणीकरण खाते बनाने के लिए:**
    ```bash
    node tools/scripts/create-auth-users.js
    ```

---

## 📢 प्रमोशन सिस्टम कैसे काम करता है

यह सिस्टम आपको किसी विशिष्ट व्यापारी को एक पूरी तरह से ब्रांडेड, अनुकूलित अनुभव के साथ प्रचारित करने की अनुमति देता है। यह ऐप के मुख्य UI घटकों को ओवरराइड करने के लिए एक डेटा-चालित दृष्टिकोण का उपयोग करता है।

### शामिल फाइलें:
-   **कॉन्फ़िगरेशन:** `/source/settings/config.json` (यहाँ आप `flags.promotionEnabled` को `true` पर सेट करते हैं)
-   **प्रमोशन डेटा:** `/localstore/jsons/promotions.json` (या Firestore में `promotions` कलेक्शन)
-   **मुख्य लॉजिक:** `/source/main.js`
-   **UI कंपोनेंट्स:** `/source/partials/navigations/top-nav.html`, `/source/partials/footer/footer.html`, `/source/partials/navigations/bottom-nav.html`

### वर्कफ़्लो:
1.  **सक्रियण:** `config.json` में, `flags.promotionEnabled` को `true` पर सेट करें।
2.  **प्रारंभ:** जब ऐप लोड होता है, तो `main.js` में `initializeApp` फ़ंक्शन जांचता है कि `flags.promotionEnabled` ध्वज `true` है या नहीं।
3.  **डेटा फ़ेच:** यह `data-manager.js` से `fetchActivePromotion()` को कॉल करता है, जो `promotions.json` से `isActive: true` वाले प्रमोशन को प्राप्त करता है।
4.  **इवेंट डिस्पैच:** यदि कोई सक्रिय प्रमोशन मिलता है, तो `main.js` एक वैश्विक `promotionActivated` कस्टम इवेंट भेजता है, जिसमें प्रमोशन का पूरा डेटा `event.detail` में होता है।
5.  **UI अपडेट:** `header.html`, `footer.html`, और `tab-nav.html` में स्क्रिप्ट्स इस `promotionActivated` इवेंट को सुनती हैं। जब इवेंट पकड़ा जाता है, तो वे अपने डिफ़ॉल्ट HTML और स्टाइल को प्रमोशन डेटा (जैसे कस्टम लोगो, रंग, लिंक और बटन) से ओवरराइड कर देते हैं, जिससे एक पूरी तरह से ब्रांडेड अनुभव बनता है।

## 🔮 भविष्य की योजनाएं (Future Plans)

-   **क्लाउड फंक्शन्स:** `campaigns` कलेक्शन के आधार पर स्वचालित रूप से अलर्ट बनाने जैसे बैकएंड लॉजिक को लागू करना।
-   **फायरबेस स्टोरेज:** उपयोगकर्ता द्वारा अपलोड की गई छवियों (जैसे अवतार, आइटम चित्र) को संभालना।
-   **उन्नत कैशिंग:** मजबूत ऑफ़लाइन क्षमताओं के लिए IndexedDB का उपयोग करना।
-   **OTP-आधारित फ़ोन लॉगिन:** वर्तमान असुरक्षित फ़ोन नंबर लॉगिन को एक सुरक्षित, OTP-आधारित प्रणाली से बदलना।
-   **पूर्ण सब्सक्रिप्शन प्रबंधन:** भुगतान गेटवे (जैसे Stripe, Razorpay) को एकीकृत करना और सब्सक्रिप्शन योजनाओं के लिए स्वचालित नवीनीकरण और चालान-प्रक्रिया को संभालना।
-   **डेस्कटॉप व्यू:** `@media` क्वेरी के साथ डेस्कटॉप अनुभव में सुधार करना।
-   **एकीकृत परीक्षण (Unit & E2E Testing):** ऐप की स्थिरता और विश्वसनीयता सुनिश्चित करने के लिए Jest या Cypress जैसे फ्रेमवर्क को लागू करना।


---
