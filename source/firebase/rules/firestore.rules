rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    // These functions make the rules cleaner and easier to read.

    // Checks if the requesting user is a Admin.
    // This relies on a custom claim set on the user's auth token.
    // Custom claims are the most secure and efficient way to handle roles.
    function isAdmin() {
      return request.auth != null && request.auth.token.isAdmin == true;
    }

    // Checks if the requesting user's UID matches the UID provided.
    function isRequestingUser(uid) {
      return request.auth != null && request.auth.uid == uid;
    }

    // Checks if the user owns the document they are trying to access.
    // It compares the requester's UID with the UID stored inside the document.
    function isOwnerOfDoc() {
      return isRequestingUser(resource.data.auth.provider.uid);
    }

    // Checks if the user is creating a document for themselves.
    function isCreatingOwnDoc() {
        return isRequestingUser(request.resource.data.auth.provider.uid);
    }

    // Checks if the user owns a document that is linked via a custom user ID.
    // This performs a cross-document read to get the user's auth UID for comparison.
    // It's used for collections like 'accounts', 'logs', and 'orders'.
    function isOwnerOfLinkedDoc(customUserId) {
      return isRequestingUser(get(/databases/$(database)/documents/users/$(customUserId)).data.auth.provider.uid);
    }

    // --- PUBLIC COLLECTIONS ---
    // These collections are readable by anyone, even unauthenticated guests.
    // This is crucial for the app to load initial data like categories and items for all users.
    // Writes are restricted to Admins to prevent unauthorized changes.
    match /items/{itemId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    match /promotions/{promoId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    match /brands/{brandId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    match /units/{unitId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // --- USER-SPECIFIC COLLECTIONS ---

    match /users/{userId} {
      // READ: A user can read their own profile, or a Admin can read any profile.
      // DEV-ONLY RULE: The 'list' permission is temporarily opened to allow two things for testing:
      // 1. Authenticated users can check if a phone number exists during registration.
      // 2. Authenticated users can find their user document by UID after login (self-healing).
      // WARNING: This rule is for development. It allows any logged-in user to query the users collection.
      // For production, this should be restricted to Admins only. Phone number uniqueness should be handled by a Cloud Function.
      allow list: if request.auth != null || isAdmin();

      // READ (GET): A user can always get their own document.
      // For the development 'impersonation' feature to work, we temporarily allow any
      // authenticated user to read any user profile. This relies on the app's UI to restrict access.
      // PRODUCTION FIX: Tighten this rule to prevent data leaks.
      allow get: if request.auth != null || isAdmin();
      // UPDATE: A user can update their own profile, or a Admin can update any profile.
      allow update: if isOwnerOfDoc() || isAdmin();
      // CREATE: A new user can create their own profile. This rule matches your `createUserDocument` logic.
      allow create: if isCreatingOwnDoc() || isAdmin();
      // DELETE: Only a Admin can delete a user profile.
      allow delete: if isAdmin();
    }

    // --- MERCHANT-SPECIFIC COLLECTIONS ---
    match /merchants/{merchantId} {
      // Public storefronts can be read by anyone.
      allow read: if true; // Allow public read for storefronts
      // UPDATE: Only the linked owner (via custom userId) or an Admin can update a merchant profile.
      // This uses the same ownership check as accounts, logs, etc. for consistency.
      allow update: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
      // CREATE: A user can create a merchant document linked to their own userId.
      allow create: if isOwnerOfLinkedDoc(request.resource.data.meta.links.userId) || isAdmin();
      // DELETE: Only an Admin can delete a merchant profile.
      allow delete: if isAdmin();
    }

    // --- NEW: Story-specific rules ---
    match /stories/{merchantId} {
      // Anyone can read stories.
      allow read: if true;
      // Only the linked owner or an Admin can create stories.
      allow create: if isOwnerOfLinkedDoc(request.resource.data.meta.links.userId) || isAdmin();
      // Only the linked owner or an Admin can update/delete stories.
      allow update, delete: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
    }

    // Alerts are linked to users and should only be accessible by them or an Admin.
    match /alerts/{alertId} {
      allow read, update: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
      allow create: if isOwnerOfLinkedDoc(request.resource.data.meta.links.userId) || isAdmin();
      allow delete: if isAdmin();
    }

    // --- CRITICAL USER DATA (e.g., accounts) ---
    // This rule is separate for clarity, as the account is created with the user.
    // The security logic is identical to other user-owned data but kept separate for readability.
    match /accounts/{accountId} {
      allow read, update: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
      // Use a direct UID check on create to avoid the get() race condition.
      // The `ownerUID` is added to the document temporarily during creation by the client.

      allow create: if request.auth !=null;
      allow delete: if isAdmin();
    }

    // --- OTHER USER-OWNED COLLECTIONS ---
    // These rules use a 'get()' call to check ownership via the linked user document.
    match /logs/{logId} {
      // Read/Update rules can safely use get() as the document already exists.
      allow read, update: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
      // Create rule must use a direct UID check to avoid race conditions during signup.
      // The client must pass the auth UID in the document being created.
      allow create: if isRequestingUser(request.resource.data.meta.ownerUID) || isAdmin();
      allow delete: if isAdmin();
      allow create: if request.auth !=null;
    }
    match /orders/{orderId} {
      allow read, update: if isOwnerOfLinkedDoc(resource.data.meta.links.userId) || isAdmin();
      allow create: if isOwnerOfLinkedDoc(request.resource.data.meta.links.userId) || isAdmin();
      allow delete: if isAdmin();
    }

    // --- SYSTEM COLLECTIONS ---
    // The counters collection is used to generate sequential IDs atomically.
    // It should only be updated by authenticated users during creation flows
    // (e.g., creating a user, account, log, etc.).
    match /counters/{counterId} {
      allow read, write: if request.auth != null || isAdmin();
    }

    // --- ADMIN-ONLY & SYSTEM COLLECTIONS ---
    // These collections can only be written to or read by Admins.
    // Note: The wildcard name (e.g., priceLogId) should be descriptive.
    match /price-logs/{priceLogId} {
        allow read, write: if isAdmin();
    }

    // Campaigns are definitions for mass-messaging, only Admins can create/manage them.
    // The actual delivery to users is handled by a trusted backend (Cloud Function).
    match /campaigns/{campaignId} {
      allow read, write: if isAdmin();
    }
  }
}

// deploy code > 
//firebase deploy --only firestore:rules